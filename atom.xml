<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hey U</title>
  
  <subtitle>何小宇的窝</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://heyu.cloud/"/>
  <updated>2018-09-22T16:53:55.452Z</updated>
  <id>https://heyu.cloud/</id>
  
  <author>
    <name>Heyu Gong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 optimize.minimize(method=&#39;SLSQP&#39;) 的一些心得</title>
    <link href="https://heyu.cloud/blog/201807/%E4%BD%BF%E7%94%A8-optimize-minimize-method-SLSQP-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/"/>
    <id>https://heyu.cloud/blog/201807/使用-optimize-minimize-method-SLSQP-的一些心得/</id>
    <published>2018-07-16T05:04:13.000Z</published>
    <updated>2018-09-22T16:53:55.452Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>最好要有 jac</p><p> 一般来说 jac 也不是很难求，有 jac 的时候求解答速度会快很多，成功率也会提高很多</p></li><li><p>初始 x0 最好满足边际约束条件</p><p> 初始 x0 对求解成功与否有很大影响，而且有的时候如果初始 x0 在边界外，最后就算求解成功了，姐也可能不满足边界条件。所以初始 x0 满足边界条件是一个好的开始。</p><p> 比如如果 <code>bounds = [(0, 1), (-1, 1), (0, 3)]</code> ，可以试试 <code>x0 = np.asarray(bounds).mean(axis=1)</code></p></li><li><p>target 函数的标准化</p><p> 最好限制 traget 函输出的结果“不要太大”也“不要太小”</p><p> 比如如果 <code>fun</code> 函数为</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="comment"># x 取值范围为 [-1 ,1]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> * x[<span class="number">0</span>] + <span class="number">100</span> * x[<span class="number">1</span>] - <span class="number">50</span> * x[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p> 最好把函数变为</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>] + x[<span class="number">1</span>] - <span class="number">0.5</span> * x[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p> 同理如果有 <code>constraints</code> 最好也这么调整</p><p> 因为根据 <a href="https://docs.scipy.org/doc/scipy-1.0.0/reference/optimize.minimize-slsqp.html#optimize-minimize-slsqp" target="_blank" rel="noopener"><code>minimize(method=’SLSQP’)</code></a>，当效用函数</p><p> $\min_x \frac{1}{2} \sum_{i=1}^{m} \rho(f_i(x^2))$</p><p> $subject\ to\ lb \leqslant x \leqslant ub$</p><p> 的精度小于 <code>ftol</code> 这个参数时，停止求解，如果目标函数 $f_i(x)$ 的返回值太大的话，可能会报 <code>Positive directional derivative for linesearch    (Exit mode 8)</code> 这个错，或者结果和约束条件的差距的数量级比较高。</p></li><li><p><code>Inequality constraints incompatible    (Exit mode 4)</code></p><p> 这可能是由于 target 函数中有除以0或者接近除以0的错误。<br> 我没有研究过具体代码，我觉得可能是当没有提供 jac 时，target 函数中有除以0或者接近除以0的情况时，会导致估计出的 jac 也非常大，要不就是正的非常大，要不就是负的非常大，这会让求解过程很不稳定，一不小心就会导致解超出 constraints 或者 bounds。</p><p> 这种情况解决的方法（不一定对）：</p><ul><li>通过限制 bounds 使 target 函数不会有除0的情况</li><li>减小 <a href="https://docs.scipy.org/doc/scipy/reference/optimize.minimize-slsqp.html" target="_blank" rel="noopener">eps</a>，即估计 jac 时使用的步长，使 jac 的估计不那么离谱</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;最好要有 jac&lt;/p&gt;
&lt;p&gt; 一般来说 jac 也不是很难求，有 jac 的时候求解答速度会快很多，成功率也会提高很多&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初始 x0 最好满足边际约束条件&lt;/p&gt;
&lt;p&gt; 初始 x0 对求解成功与否有很大影响，而且有的时
      
    
    </summary>
    
    
      <category term="python, scipy, optimize" scheme="https://heyu.cloud/tags/python-scipy-optimize/"/>
    
  </entry>
  
  <entry>
    <title>Atom 配置 - for Python</title>
    <link href="https://heyu.cloud/blog/201704/Atom-%E9%85%8D%E7%BD%AE-for-Python/"/>
    <id>https://heyu.cloud/blog/201704/Atom-配置-for-Python/</id>
    <published>2017-03-31T17:07:16.000Z</published>
    <updated>2017-04-01T05:15:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://atom.io/" target="_blank" rel="noopener">Atom</a></strong> 是 Github 开发的一个文本编辑器，高度可定制而不需要写烦人的配置文件,而且有 Github 社区为其开发的丰富的插件。</p><ul><li>自带包管理 apm</li><li>智能补全, 预装文件浏览树</li><li>跨平台编辑</li><li>颜控必备, 丰富UI和语法高亮, 还能自己进行配置</li><li>听说对前端开发很友好</li></ul><h3 id="1-语法支持"><a href="#1-语法支持" class="headerlink" title="1. 语法支持"></a>1. 语法支持</h3><p>(1). <strong><a href="https://atom.io/packages/language-python" target="_blank" rel="noopener">language-python</a></strong></p><p>  Atom 自带的 Python 语法和片段高亮支持。</p><h3 id="2-自动补全和美化"><a href="#2-自动补全和美化" class="headerlink" title="2. 自动补全和美化"></a>2. 自动补全和美化</h3><p>(1). <strong><a href="https://atom.io/packages/autocomplete-python" target="_blank" rel="noopener">autocomplete-python</a></strong></p><p>  用于自动补全 Python 变量，方法，函数及其参数。是使用的插件。</p><p>  <img src="https://i.github-camo.com/9cb3e21999f92079ca5393b718784f81be458afa/68747470733a2f2f636c6f75642e67697468756275736572636f6e74656e742e636f6d2f6173736574732f3139333836342f31323238383432372f36316665323131342d626130662d313165352d393833322d3938383639313830643837662e676966" alt="autocomplete-python"></p><p>(2). <strong><a href="https://atom.io/packages/python-indent" target="_blank" rel="noopener">python-indent</a></strong></p><p>  用于回车自动缩进</p><p>  <img src="https://i.github-camo.com/8573120d484e444ce9241409bf25463939b7c0ec/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f44537065636b68616c732f707974686f6e2d696e64656e742f6d61737465722f7265736f75726365732f696d672f707974686f6e2d696e64656e742d64656d6f6e7374726174696f6e2e676966" alt="python-indent"></p><p>(3). <strong><a href="https://atom.io/packages/atom-beautify" target="_blank" rel="noopener">atom-beautify</a></strong></p><p>  可通过快捷键 <code>control+alt+b</code> 美化当前文件。</p><h3 id="3-运行Python"><a href="#3-运行Python" class="headerlink" title="3. 运行Python"></a>3. 运行Python</h3><p>(1). <strong><a href="https://atom.io/packages/atom-python-run" target="_blank" rel="noopener">atom-python-run</a></strong></p><p>  使 .py 文件可以直接在 Atom 中运行。按 F5 或者 F6 就可以自动打开一个 cmd 运行文件。</p><ul><li>Using python.exe<ul><li>Almost the same console with python IDLE, which provides syntax error and runtime error messages.</li></ul></li><li>CodeBlocks debug console style<ul><li>Shows return value and execution time<ul><li>It is a rough time based on real time rather than CPU kernel time or CPU user time</li></ul></li></ul></li><li><p>New an issue if you have any idea of new features.</p><p><img src="https://i.github-camo.com/602be24c3200278afd853b2077652f9dce60f1ff/68747470733a2f2f636c6f75642e67697468756275736572636f6e74656e742e636f6d2f6173736574732f323731323637352f31383731303338382f39613636356564382d383033372d313165362d383033612d3335653435353565383964302e6a7067" alt="atom-python-run"></p></li></ul><p>(2). <strong><a href="https://atom.io/packages/Hydrogen" target="_blank" rel="noopener">hydrogen</a></strong></p><p>  这个插件可以使 Atom 像 Jupyter Notebook 一样在 Atom 编辑器内部逐行运行代码并显示结果。</p><ul><li>execute a line, selection, or block at a time</li><li>rich media support for plots, images, and video</li><li>watch expressions let you keep track of variables and re-run snippets after every change</li><li>completions from the running kernel, just like autocomplete in the Chrome dev tools</li><li>code can be inspected to show useful information provided by the running kernel</li><li>one kernel per language (so you can run snippets from several files, all in the same namespace)</li><li>interrupt or restart the kernel if anything goes wrong</li><li><p>use a custom kernel connection (for example to run code inside Docker), read more in the “Custom kernel connection (inside Docker)” section</p><p><img src="https://i.github-camo.com/e17ac2bfffce4ede5cae57c3109ef7f53effc997/68747470733a2f2f636c6f75642e67697468756275736572636f6e74656e742e636f6d2f6173736574732f31333238353830382f32303336303838362f37653033653532342d616330332d313165362d393137362d3337363737663232363631392e676966" alt="hydrogen"></p></li></ul><h3 id="4-代码规范"><a href="#4-代码规范" class="headerlink" title="4. 代码规范"></a>4. 代码规范</h3><p>(1). <strong><a href="https://atom.io/packages/python-autopep8" target="_blank" rel="noopener">python-autopep8</a></strong></p><p>  自动在保存时修改代码格式使其符合 Python PEP8 规范。</p><p>(2). <strong><a href="https://atom.io/packages/linter-pycodestyle" target="_blank" rel="noopener">linter-pycodestyle</a></strong></p><p>  这个插件可以实时检查代码是否符合 PEP8 规范，并在编辑器左下角提示。</p><p>(3). <strong><a href="https://atom.io/packages/linter-flake8" target="_blank" rel="noopener">linter-flake8</a></strong></p><p>  如果代码写的不规范(PEP8)，或者有语法错误，会弹出提示。</p><p>  <img src="https://i.github-camo.com/826e208290ec00e0a22c901e83cf6f13294ae2db/68747470733a2f2f636c6f75642e67697468756275736572636f6e74656e742e636f6d2f6173736574732f343237383131332f383736383438322f35326639373563362d326533662d313165352d383765342d3237633833353966643336632e676966" alt="linter-flake8"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://atom.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Atom&lt;/a&gt;&lt;/strong&gt; 是 Github 开发的一个文本编辑器，高度可定制而不需要写烦人的配置文件,而且有 Github 社区为其
      
    
    </summary>
    
      <category term="笔记" scheme="https://heyu.cloud/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Atom" scheme="https://heyu.cloud/tags/Atom/"/>
    
      <category term="Python" scheme="https://heyu.cloud/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>C++ 复杂变量声明</title>
    <link href="https://heyu.cloud/blog/201608/c-%E5%A4%8D%E6%9D%82%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/"/>
    <id>https://heyu.cloud/blog/201608/c-复杂变量声明/</id>
    <published>2016-08-20T07:17:03.000Z</published>
    <updated>2017-02-18T20:53:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 有时会出现复杂的声明，这时要注意分析的方法。</p><p><strong>c语言变量的声明始终贯彻两点：</strong></p><ol><li><p>声明和使用的语法尽量保持一致</p><p>例如：声明一个函数指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (*fun)(<span class="keyword">double</span>);</span><br></pre></td></tr></table></figure><p>使用这个函数指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line">fun=<span class="built_in">sin</span>;</span><br><span class="line"><span class="keyword">double</span> result=(*fun)(<span class="number">0.5</span>);<span class="comment">//use point fun</span></span><br></pre></td></tr></table></figure></li><li><p>声明语句不是的阅读不是按照从左往右的阅读顺序，而是要根据各个符号的优先级进行阅读的</p><blockquote><p>C++声明的优先级规则</p></blockquote><blockquote><p>A 声明从它的名字开始读取，然后按照优先级顺序依次读取;</p></blockquote><blockquote><p>B 优先级从高到低依次是：</p></blockquote><blockquote><p>B.1 声明中被括号括起来的那部分;</p></blockquote><blockquote><p>B.2 后缀操作符：</p></blockquote><blockquote><p>括号 () 表示这是一个函数，而</p></blockquote><blockquote><p>方括号 [] 表示这是一个数组;</p></blockquote><blockquote><p>B.3 前缀操作符：星号 * 表示这是一个”指向…的指针”;</p></blockquote><blockquote><p>C 如果 const 和(或) volatile 关键字的后面紧跟类型说明符(如 int，long 等)，那么它作用于类型说明符。在其他情况下，它作用于关键字左边紧邻的指针星号。</p></blockquote><p>需要强调的重要注意点是，对于优先级: () &gt; [] &gt; * ；结合律是”自右向左”。</p></li></ol><hr><p>i.e.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *(* c[<span class="number">10</span>]) (<span class="keyword">int</span> **p);</span><br></pre></td></tr></table></figure><table><thead><tr><th>步骤</th><th>分解</th><th>解释</th><th>依据</th></tr></thead><tbody><tr><td>第一步</td><td><code>(c)</code></td><td>最左边的标志符是<code>c</code></td><td>A &amp; B.1</td></tr><tr><td>第二步</td><td><code>(c[10])</code></td><td>和后缀<code>[10]</code>结合，表示<code>c</code>一个长度为10的数组</td><td>B.2</td></tr><tr><td>第三步</td><td><code>(*c[10])</code></td><td>和<code>*</code>结合表示<code>c[10]</code>中存储的是指针</td><td>B.3</td></tr><tr><td>第四步</td><td><code>(*c[10])((int **p)</code></td><td>和<code>(int **p)</code>结合，表示”这个指针指向一个函数，函数的参数是二维指针</td><td>B.2</td></tr><tr><td>第五步</td><td><code>char *(*c[10])((int **p)</code></td><td>和<code>char *</code> 结合，表示”这个函数返回一个指向字符的指针</td><td>B.2</td></tr></tbody></table><p>所以，c是一个数组[0..9]，它存放着指针，指针指向的函数参数是一个二维指针，返回值是指向字符的指针。</p><p>完工!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C++ 有时会出现复杂的声明，这时要注意分析的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;c语言变量的声明始终贯彻两点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;声明和使用的语法尽量保持一致&lt;/p&gt;
&lt;p&gt;例如：声明一个函数指针&lt;/p&gt;
&lt;figure class=&quot;h
      
    
    </summary>
    
      <category term="笔记" scheme="https://heyu.cloud/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://heyu.cloud/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Quantopian Turtorials Notes #2</title>
    <link href="https://heyu.cloud/blog/201608/Quantopian-Note-2/"/>
    <id>https://heyu.cloud/blog/201608/Quantopian-Note-2/</id>
    <published>2016-08-13T08:14:48.000Z</published>
    <updated>2017-02-18T22:41:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://www.quantopian.com/learn" target="_blank" rel="noopener">Quantopian</a>笔记系列</strong></p><h3 id="Lesson-3-Referencing-Securities"><a href="#Lesson-3-Referencing-Securities" class="headerlink" title="Lesson 3 Referencing Securities"></a><a href="https://www.quantopian.com/tutorials/getting-started#lesson3" target="_blank" rel="noopener">Lesson 3 Referencing Securities</a></h3><p>在 <strong>Pipeline API</strong> module 中，有两个手动选择证券的方法：</p><ul><li><p><code>sid()</code></p><ul><li>优点： 稳定。一个证券的 sid 不会变，但 ticker 有可能变。</li></ul></li><li><p><code>symbol()</code></p><ul><li>缺点： 不稳定。</li></ul></li></ul><h3 id="Lesson-4-Ordering-Securities"><a href="#Lesson-4-Ordering-Securities" class="headerlink" title="Lesson 4 Ordering Securities"></a><a href="https://www.quantopian.com/tutorials/getting-started#lesson4" target="_blank" rel="noopener">Lesson 4 Ordering Securities</a></h3><p>Quantopian 提供了很多<a href="https://www.quantopian.com/help#api-order-methods" target="_blank" rel="noopener">下单的方法</a></p><ul><li><p><code>order_target_percent(security, percent, style=type)</code>: Place an order to adjust a position to a target percent of the current portfolio value.</p><ul><li><p>Parameters</p><ul><li>security: A security object.</li><li>percent: The portfolio percentage allocated to the security. Positive means buy, negative means sell.</li><li><p>type: (optional) Specifies the order style and the default is a market order. The available order styles are:</p><ul><li>style=MarketOrder(exchange)</li><li>style=StopOrder(stop_price, exchange)</li><li>style=LimitOrder(limit_price, exchange)</li><li>style=StopLimitOrder(limit_price=price1, stop_price=price2, exchange)</li></ul></li></ul></li><li><p>i.e.</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(context)</span>:</span></span><br><span class="line">  context.aapl = sid(<span class="number">24</span>)</span><br><span class="line">  context.spy = sid(<span class="number">8554</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_data</span><span class="params">(context, data)</span>:</span></span><br><span class="line">  <span class="comment"># Note: data.can_trade() is explained in the next lesson</span></span><br><span class="line">  <span class="keyword">if</span> data.can_trade(context.aapl):</span><br><span class="line">      order_target_percent(context.aapl, <span class="number">0.60</span>)</span><br><span class="line">  <span class="keyword">if</span> data.can_trade(context.spy):</span><br><span class="line">      order_target_percent(context.spy, <span class="number">-0.40</span>)</span><br></pre></td></tr></table></figure><p>这个例子就是做多 AAPL，价值占整个 portfolio 的 60%， 做空 SPY ETF，价值占整个 portfolio 的 40%。</p></li></ul><h3 id="Lesson-5-The-data-Object"><a href="#Lesson-5-The-data-Object" class="headerlink" title="Lesson 5 The data Object"></a><a href="https://www.quantopian.com/tutorials/getting-started#lesson5" target="_blank" rel="noopener">Lesson 5 The <code>data</code> Object</a></h3><p><code>data</code> 类包含了可以用在 <code>handle_data()</code> 和 <code>before_trading_start()</code> 以及其它一些 <em>scheduled functions</em> 中的函数</p><ul><li><p><a href="https://www.quantopian.com/help#api-data-current" target="_blank" rel="noopener"><code>data.current(assets, fields)</code></a>: Can be used to retrieve the most recent value of a given field(s) for a given asset(s).</p><ul><li><p>Parameters</p><ul><li>assets: Asset or iterable of Assets.</li><li>fields: string or iterable of strings. Valid values are ‘price’, ‘last_traded’, ‘open’, ‘high’, ‘low’, ‘close’, ‘volume’, or column names in Fetcher files.</li></ul></li><li><p>Return Value: 返回值为 <em>单一值</em> 或者 <em>pd.Series</em> 或者 <em>pd.DataFrame</em> 类型。</p></li><li><p>notes:</p><ul><li><em>price</em> 如果找不到 last price，则返回 <em>NaN</em>。</li><li>_last_traded_ 返回 last trade 的日期。如果找不到值，则返回 <em>pd.NaT</em>。</li><li><em>volume</em> 返回上一分钟内成交量。</li></ul></li><li><p>i.e.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.current([sid(<span class="number">24</span>), sid(<span class="number">8554</span>)], [<span class="string">'low'</span>, <span class="string">'high'</span>])</span><br></pre></td></tr></table></figure><p>这个例子返回一个 pd.DataFrame 类型。</p></li></ul></li><li><p><a href="https://www.quantopian.com/help#api-data-can_trade" target="_blank" rel="noopener"><code>data.can_trade(assets)</code></a>: Is used to determine if an asset(s) is currently listed on a supported exchange and can be ordered.</p><ul><li><p>Parameters</p><ul><li>assets: Asset or iterable of Assets.</li></ul></li><li><p>Return Value: 返回 boolean or Series of booleans, indexed by asset. 如果 asset 有 last price，又在当前的一分钟内可交易，就会返回 true value。</p></li><li><p>i.e.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.can_trade(sid(<span class="number">24</span>))</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Lesson-6-The-history-Function"><a href="#Lesson-6-The-history-Function" class="headerlink" title="Lesson 6 The history() Function"></a><a href="https://www.quantopian.com/tutorials/getting-started#lesson6" target="_blank" rel="noopener">Lesson 6 The <code>history()</code> Function</a></h3><p>在 <code>data</code> 对象中有一个常用的函数 —- <code>history()</code>，它是用来获取历史价格和成交量数据的。</p><p><code>history()</code> 包含四个参数：an asset or list of assets, a field or list of fields, an integer lookback window length, 以及 a lookback frequency。</p><ul><li><p>Parameters</p><ul><li>an list of assets: 这个参数要求股票的 sid 的列表。</li><li>a field or list of field: 这个参数要求一个字符串或者列表，可以是 <code>&#39;price&#39;</code>, <code>&#39;open&#39;</code>, <code>&#39;high&#39;</code>, <code>&#39;low&#39;</code>, <code>&#39;close&#39;</code>, 和 <code>&#39;volume&#39;</code> 中的一个（字符串）或者几个（列表）。</li><li>an integer lookback window length： 这个参数要求一个整数，代表回看窗口的长度。例如回看窗口长度为2，frequency 参数值为’1d’，则 history() 返回的历史数据的时间跨度为 2 * 1d = 2d 。</li><li>a lookback frequency: 这个参数用来定义数据的频率，可以是<code>&#39;1d&#39;</code> (daily) 或者 <code>&#39;1m&#39;</code> (minutely)。</li></ul></li><li><p>Return value：放回值为 Pandas.Series 或者 Pandas.DataFrame</p></li><li><p>Notes: 如果 frequency 的值为 <code>&#39;1d&#39;</code>，则最近一天的值可能为这一天中某个时刻的值。比如 <code>hist = data.history(sid(24), &#39;price&#39;, 10, &#39;1d&#39;)</code>,如果在9：31发出请求，则会返回前9天 AAPL 的收盘价格，和今天9：31分 AAPL 的价格。</p></li><li><p>i.e.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get the last 5 minutes of volume data for each security in our list.</span></span><br><span class="line">hist = data.history([sid(<span class="number">24</span>), sid(<span class="number">8554</span>), sid(<span class="number">5061</span>)], <span class="string">'volume'</span>, <span class="number">5</span>, <span class="string">'1m'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate the mean volume for each security in our DataFrame.</span></span><br><span class="line">mean_volumes = hist.mean(axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这个例子首先返回一个 Pandas.DataFrame 结构，列分别表示三个资产，行（索引）为不同的时间。然后求出三个资产的平均价格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Low and high minute bar history for each of our securities.</span></span><br><span class="line">hist = data.history([sid(<span class="number">24</span>), sid(<span class="number">8554</span>), sid(<span class="number">5061</span>)], [<span class="string">'low'</span>, <span class="string">'high'</span>], <span class="number">5</span>, <span class="string">'1m'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate the mean low and high over the last 5 minutes</span></span><br><span class="line">means = hist.mean()</span><br><span class="line">mean_lows = means[<span class="string">'low'</span>]</span><br><span class="line">mean_highs = means[<span class="string">'high'</span>]</span><br></pre></td></tr></table></figure><p>这个例子首先返回一个 <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Panel.html" target="_blank" rel="noopener">Pandas.Panel</a> 结构，分为三个维度，第一个维度（minor axis）表示不同的三个资产，第二个维度（index）表示最低价和最高价，第三个维度（main axis）表示不同的时间。 然后根据 <code>means = hist.mean()</code> 返回的是一个 library，library 中的键值分别为 <code>&#39;low&#39;</code> 和 <code>&#39;high&#39;</code>，值分别为三个股票的最低价均值和最高价均值的 library。（例如用 <code>means[&#39;low&#39;][&#39;sid(24)&#39;]</code>可以查询 AAPL 的最低价的均值）</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.quantopian.com/learn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Quantopian&lt;/a&gt;笔记系列&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;Lesson-3-Refere
      
    
    </summary>
    
      <category term="笔记" scheme="https://heyu.cloud/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://heyu.cloud/tags/Python/"/>
    
      <category term="Quantopian" scheme="https://heyu.cloud/tags/Quantopian/"/>
    
  </entry>
  
  <entry>
    <title>Quantopian Turtorials Notes #1</title>
    <link href="https://heyu.cloud/blog/201608/Quantopian-Note-1/"/>
    <id>https://heyu.cloud/blog/201608/Quantopian-Note-1/</id>
    <published>2016-08-13T08:14:40.000Z</published>
    <updated>2017-02-18T22:40:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://www.quantopian.com/learn" target="_blank" rel="noopener">Quantopian</a>笔记系列</strong></p><h3 id="Lesson-1-Introduction"><a href="#Lesson-1-Introduction" class="headerlink" title="Lesson 1 Introduction"></a><a href="https://www.quantopian.com/tutorials/getting-started#lesson1" target="_blank" rel="noopener">Lesson 1 Introduction</a></h3><p>在Quantopian，有两个特殊函数，<code>initialize()</code> 和 <code>handle_data()</code> ：</p><ul><li><p><code>initialize()</code> : to perform any one-time startup logic</p></li><li><p><code>handle_data()</code> : to decide what orders, if any, should be placed each minute</p></li></ul><p>i.e.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(context)</span>:</span></span><br><span class="line">  <span class="comment"># Reference to AAPL</span></span><br><span class="line">  context.aapl = sid(<span class="number">24</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_data</span><span class="params">(context, data)</span>:</span></span><br><span class="line">  <span class="comment"># Position 100% of our portfolio to be long in AAPL</span></span><br><span class="line">  order_target_percent(context.aapl, <span class="number">1.00</span>)</span><br></pre></td></tr></table></figure><p>上面这个例子是一个把100%的钱投入到AAPL中。 其中，</p><ul><li><code>context.aapl</code> 是给名为 <em>context</em> 的 <strong>augmented Python dictionary</strong> 添加一个名为 <em>AAPL</em> 的元素。</li><li><code>sid()</code> 函数是 Stock_ID 的意思，<code>sid(24)</code>表示 ID 为24的证券（就是AAPL）。部分sid可以参考 <a href="https://www.quantopian.com/posts/sid-slash-ticker-set" target="_blank" rel="noopener">Sid/Ticker Set</a>。其实 <code>sid()</code> 不好用，可以用其他函数直接通过ticker获取股票信息。</li><li><code>order_target_percent</code> 是一个函数，通过字面意思就可以理解，就是把资金按照一定的目标百分比分配给资产组合中到证券（百分比之和可以不等于100%）。这里就是把100%的资金分配给 AAPL。</li></ul><p>关于数据源，Quantopian 给免费用户提供 <a href="https://www.quantopian.com/help#fundamental-data" target="_blank" rel="noopener">Morningstar fundamentals data</a>，包括柱状历史价格，交易量什么的。还有各种第三方的 <a href="https://www.quantopian.com/data" target="_blank" rel="noopener">Datasets</a>。</p><h3 id="Lesson-2-Core-Functions"><a href="#Lesson-2-Core-Functions" class="headerlink" title="Lesson 2 Core Functions"></a><a href="https://www.quantopian.com/tutorials/getting-started#lesson2" target="_blank" rel="noopener">Lesson 2 Core Functions</a></h3><p>一个 Quantopian 的算法有3个核心函数，<code>initialize()</code>，<code>handle_data()</code>和<code>before_trading_start()</code>。</p><ul><li><p><code>initialize(context)</code></p><ol><li>Must have.</li><li>Is called exactly once when our algorithm starts.</li><li><strong>context</strong> 是 <strong>augmented Python dictionary</strong>，是一个 <strong>global variable</strong>。可以通过 dot notation 来获取其中的元素（<code>context.some_property</code>）。</li></ol></li><li><p><code>handle_data(context, data)</code></p><ol><li>Optional</li><li>Is called once at the end of each minute.</li><li><strong>context</strong> 和 <code>initialize(context)</code> 中的 context 一样。</li><li><strong>data</strong> 是包含一些 API function 的对象。</li></ol></li><li><p><code>before_trading_start(context, data)</code>: Is called once per day before the market opens</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.quantopian.com/learn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Quantopian&lt;/a&gt;笔记系列&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;Lesson-1-Introd
      
    
    </summary>
    
      <category term="笔记" scheme="https://heyu.cloud/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://heyu.cloud/tags/Python/"/>
    
      <category term="Quantopian" scheme="https://heyu.cloud/tags/Quantopian/"/>
    
  </entry>
  
  <entry>
    <title>SWIFT iOS 笔记 - 井字棋</title>
    <link href="https://heyu.cloud/blog/201605/SWIFT-iOS-%E7%AC%94%E8%AE%B0%20-%20%E4%BA%95%E5%AD%97%E6%A3%8B/"/>
    <id>https://heyu.cloud/blog/201605/SWIFT-iOS-笔记 - 井字棋/</id>
    <published>2016-05-18T14:06:24.000Z</published>
    <updated>2017-02-18T22:39:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天学做了一个<strong>井字棋</strong>的游戏，</p><p><a href="http://snapgr.am/image/L0Qc" target="_blank" rel="noopener"><img src="http://cdn3.snapgram.co/imgs/2016/05/18/SimulatorScreenShotMay18201623.33.08.png" alt="SimulatorScreenShotMay18201623.33.08.png"></a></p><p><a href="http://snapgr.am/image/L0Q7" target="_blank" rel="noopener"><img src="http://cdn2.snapgram.co/imgs/2016/05/18/SimulatorScreenShotMay18201623.28.28.png" alt="SimulatorScreenShotMay18201623.28.28.png"></a> <a href="http://snapgr.am/image/L0QI" target="_blank" rel="noopener"><img src="http://cdn1.snapgram.co/imgs/2016/05/18/SimulatorScreenShotMay18201623.25.17.png" alt="SimulatorScreenShotMay18201623.25.17.png"></a></p><p>步骤如下：</p><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h3><p>首先是准备素材，一共是三个png格式的图片，用作双方的棋子和棋盘：</p><p><a href="http://snapgr.am/image/L0Qn" target="_blank" rel="noopener"><img src="http://cdn1.snapgram.co/imgs/2016/05/18/cross.th.png" alt="cross.th.png"></a> <a href="http://snapgr.am/image/L0Qy" target="_blank" rel="noopener"><img src="http://cdn3.snapgram.co/imgs/2016/05/18/nought.th.png" alt="nought.th.png"></a> <a href="http://snapgr.am/image/L0Q6" target="_blank" rel="noopener"><img src="http://cdn4.snapgram.co/images/2016/05/18/board.th.png" alt="board.th.png"></a></p><h3 id="2-布局"><a href="#2-布局" class="headerlink" title="2. 布局"></a>2. 布局</h3><ol><li>首先最下层的棋盘，是 Image View 。</li><li>然后是9个可以落子的区域，是在井字格的9个个小方块处各添加一个正方形的 Button。</li><li>最后是显示结果的 Label 和 Play Again 按钮，放在最上方，默认隐藏。</li></ol><p><a href="http://snapgr.am/image/L0Ql" target="_blank" rel="noopener"><img src="http://cdn4.snapgram.co/images/2016/05/18/Framework.png" alt="Framework.png"></a></p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="type">NextMove</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> board = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="type">Ended</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="type">WinCondition</span> = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> c1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> c2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> c3 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> draw = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> <span class="type">ResultLabel</span>: <span class="type">UILabel</span>!</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> <span class="type">PlayAgainButtonView</span>: <span class="type">UIButton</span>!</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">Button</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">NextMove</span> == <span class="number">1</span> &amp;&amp; board[sender.tag-<span class="number">1</span>]==<span class="number">0</span> &amp;&amp; <span class="type">Ended</span>==<span class="number">0</span> &#123;</span><br><span class="line">            sender.setImage(<span class="type">UIImage</span>(named: <span class="string">"nought.png"</span>), forState: .<span class="type">Normal</span>)</span><br><span class="line">            <span class="type">NextMove</span> = <span class="number">2</span></span><br><span class="line">            board[sender.tag-<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">NextMove</span> == <span class="number">2</span> &amp;&amp; board[sender.tag-<span class="number">1</span>]==<span class="number">0</span> &amp;&amp; <span class="type">Ended</span>==<span class="number">0</span> &#123;</span><br><span class="line">            sender.setImage(<span class="type">UIImage</span>(named: <span class="string">"cross.png"</span>), forState: .<span class="type">Normal</span>)</span><br><span class="line">            <span class="type">NextMove</span> = <span class="number">1</span></span><br><span class="line">            board[sender.tag-<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> condition <span class="keyword">in</span> <span class="type">WinCondition</span> &#123;</span><br><span class="line">            c1 = condition[<span class="number">0</span>]-<span class="number">1</span></span><br><span class="line">            c2 = condition[<span class="number">1</span>]-<span class="number">1</span></span><br><span class="line">            c3 = condition[<span class="number">2</span>]-<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> board[c1]==board[c2] &amp;&amp; board[c2]==board[c3] &amp;&amp; board[c1]*board[c2]*board[c3] != <span class="number">0</span> &amp;&amp; <span class="type">Ended</span>==<span class="number">0</span> &#123;</span><br><span class="line">                <span class="type">Ended</span>=<span class="number">1</span></span><br><span class="line">                <span class="type">ResultLabel</span>.text=<span class="string">"Player <span class="subst">\(board[c1])</span> Win!"</span></span><br><span class="line">                <span class="type">ResultLabel</span>.hidden=<span class="literal">false</span></span><br><span class="line">                <span class="type">PlayAgainButtonView</span>.hidden=<span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> board &#123;</span><br><span class="line">            draw *= i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> draw != <span class="number">0</span> &amp;&amp; <span class="type">Ended</span>==<span class="number">0</span> &#123;</span><br><span class="line">            <span class="type">Ended</span>=<span class="number">1</span></span><br><span class="line">            <span class="type">ResultLabel</span>.text=<span class="string">"Draw"</span></span><br><span class="line">            <span class="type">ResultLabel</span>.hidden=<span class="literal">false</span></span><br><span class="line">            <span class="type">PlayAgainButtonView</span>.hidden=<span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            draw = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> <span class="type">CollectionOfViews</span>: <span class="type">Array</span>&lt;<span class="type">UIButton</span>&gt;?</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">PlayAgainButton</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">        board = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        draw = <span class="number">1</span></span><br><span class="line">        <span class="type">Ended</span> = <span class="number">0</span></span><br><span class="line">        <span class="type">ResultLabel</span>.hidden = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> <span class="type">Buttons</span> <span class="keyword">in</span> <span class="type">CollectionOfViews</span>! &#123;</span><br><span class="line">            <span class="type">Buttons</span>.setImage(<span class="literal">nil</span>, forState: .<span class="type">Normal</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">PlayAgainButtonView</span>.hidden = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，九个 Button 全部连接到</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">Button</span><span class="params">(sender: AnyObject)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">var</span> <span class="type">CollectionOfViews</span>: <span class="type">Array</span>&lt;<span class="type">UIButton</span>&gt;?</span><br></pre></td></tr></table></figure><p>这两个代码块上；</p><p>显示比赛结果的 Label 连接到</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> <span class="type">ResultLabel</span>: <span class="type">UILabel</span>!</span><br></pre></td></tr></table></figure><p>Play Again Button 连接到</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> <span class="type">PlayAgainButtonView</span>: <span class="type">UIButton</span>!</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">PlayAgainButton</span><span class="params">(sender: AnyObject)</span></span></span><br></pre></td></tr></table></figure><h3 id="Anything-New"><a href="#Anything-New" class="headerlink" title="Anything New"></a>Anything New</h3><ul><li><p>功能类似的UI组件可以链接到同一个代码区块上。比如说9个button，没有功能上的区别，所以就都都连接到同样的两个代码区块上，不用重复建9个。</p></li><li><p>如果一个代码区块被许多Object链接，可以通过设置tag来区分:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sender.tag</span><br></pre></td></tr></table></figure></li><li><p>设置botton的图片的函数为</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sender.setImage(<span class="type">UIImage</span>(named: <span class="string">"nought.png"</span>), forState: .<span class="type">Normal</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天学做了一个&lt;strong&gt;井字棋&lt;/strong&gt;的游戏，&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://snapgr.am/image/L0Qc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;http://cdn3.snapgra
      
    
    </summary>
    
      <category term="笔记" scheme="https://heyu.cloud/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="iOS" scheme="https://heyu.cloud/tags/iOS/"/>
    
      <category term="SWIFT" scheme="https://heyu.cloud/tags/SWIFT/"/>
    
      <category term="Tic-Tac-Toe" scheme="https://heyu.cloud/tags/Tic-Tac-Toe/"/>
    
  </entry>
  
</feed>
